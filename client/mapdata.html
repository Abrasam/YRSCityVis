<!-- Gl Matrix - matrix library-->
<script type="text/javascript" src="gl-matrix-min.js" ></script>

<!-- Util script lib by me-->
<script type="text/javascript" src="utils.js" ></script>

<script id="shader.fragment" type="x-shader/x-fragment">
    precision mediump float;


    void main(void) {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 0.5);
        //gl_FragColor = vColor;
    }
</script>

<script id="shader.vertex" type="x-shader/x-vertex">
    attribute vec3 position;
    //attribute vec4 basic_color;

    uniform mat4 uFmatrix;
    uniform mat4 uMRmatrix;


    varying vec3 v;
    varying vec3 c;

    void main(void) {
    	gl_Position = uFmatrix * uMRmatrix * vec4(position,1.0);  
        //gl_Position = vec4(position,1.0) * MVmatrix * Fmatrix
        //gl_Position = vec4(position,1.0) * MVmatrix;  //MORE DEBUG
    	//gl_Position = vec4(position, 1.0);  //#DEBUG CODE - REMOVe
    }
</script>









<!-- Javascript stuff -->
<script> //UTILITY FUNCTIONALITY FOR JAVASCRIPT

///////
function initGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
        //alert("DEBUG: LOADED");
    } catch (e) {
        //DEBUG
    }
    if (!gl) {
        alert("ERROR: Failed to initialise WebGL");
    }

}

//WebGL Access functionality
var gl = null;
/////
var draw_buffer = null; //Vertex Buffer to push
var draw_buffer_alt = null;
var draw_buffer_a = null;
var draw_buffer_b = null;

/////
var shaderProgram = null; //Shader
//
var Fmatrix = mat4.create();
var MRmatrix = mat4.create();
//
var camLoc = vec3.fromValues(-3, -3, -3)
//
var camRX = 5;
var camRY = 5;
var camRZ = 5;
//
var positionlocation;

function matrix_update() {
	//Camera update
	MRmatrix = mat4.create();
	//
	mat4.translate(MRmatrix,MRmatrix,camLoc);
	mat4.rotateX(MRmatrix,MRmatrix,camRX);
	mat4.rotateY(MRmatrix,MRmatrix,camRY);
	mat4.rotateZ(MRmatrix,MRmatrix,camRZ);
    //
    mat4.translate(MRmatrix,MRmatrix,camLoc);
    //
    Fmatrix = mat4.create();
    mat4.perspective(Fmatrix,80,gl.viewportWidth / gl.viewportHeight,0.1,100);
    //
    //mat4.identity(Fmatrix);
    //mat4.identity(MRmatrix);
    //alert(mat4.str(Fmatrix));

    //DEBUG BECAUSE
    //test_in = vec3.fromValues(1,-1,0);
    //test_out = vec3.fromValues(0,0,0);
    //test_data = mat4.create();
    //mat4.multiply(test_data,MRmatrix,Fmatrix);
    //vec3.transformMat4(test_out,test_in,test_data);
   //mat4.multiply(test_data,Fmatrix,MRmatrix);
    //alert("LOC= " + vec3.str(test_out));

	//
    //alert("DATA-MAT4: " + " mr="+mat4.str(MRmatrix)+ ", f="+mat4.str(Fmatrix));
    gl.uniformMatrix4fv(shaderProgram.fMatrixUniform, gl.FALSE, Fmatrix);
    gl.uniformMatrix4fv(shaderProgram.mrMatrixUniform, gl.FALSE, MRmatrix);
}

function addToBuffer(array,size) { //pass Float32Array
	draw_buffer_alt.numItems += size;
	gl.bufferData(gl.ARRAY_BUFFER,array, gl.STATIC_DRAW);
}

////

function switchBuffers() {
    var temp;
    temp = draw_buffer;
    draw_buffer = draw_buffer_alt;
    draw_buffer_alt = temp;
}

function bindBuffer() {
    gl.bindBuffer(gl.ARRAY_BUFFER, draw_buffer);
}


function initShaders() {
    var fragmentShader = getShader(gl, "shader.fragment");
    var vertexShader = getShader(gl, "shader.vertex");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "position");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    shaderProgram.fMatrixUniform = gl.getUniformLocation(shaderProgram, "uFmatrix");
    shaderProgram.mrMatrixUniform = gl.getUniformLocation(shaderProgram, "uMRmatrix");
}

function loadWebGL() {
    var canvas = document.getElementById("map");
    initGL(canvas);
    initShaders();
    initBuffers();
    //////
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);

    // \/ TO TURN INTO DRAW CALLING REPEATABLE
    //////draw();

}

/////
function initBuffers() {
    draw_buffer = gl.createBuffer();
    draw_buffer_alt = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, draw_buffer);
    ////////SETUP
    draw_buffer.itemSize = 3;
    draw_buffer.numItems = 0;
    gl.bindBuffer(gl.ARRAY_BUFFER, draw_buffer);
}


function init_draw() { //RESET CURRENT BUFFER FOR REUSE
    draw_buffer.numItems = 0;
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}

function addToBuffer(array,size) { //pass Float32Array
    draw_buffer.numItems += size;
    gl.bufferData(gl.ARRAY_BUFFER,array, gl.STATIC_DRAW);
}

function addToBufferA(array,size) {
    addToBuffer(new Float32Array(array),size);
}

function draw() {
    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //TEST PROB NEEDED
    switchBuffers();
    bindBuffer();   
    matrix_update();
    //
    gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);//shaderProgram.vertexPositionAttribute, draw_buffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, draw_buffer.numItems);
}








///////


</script>


<!-- Basic HTML Framework-->
<html>

<body id="body">

	<div id="frame_map" >

		<canvas id="map">


		</canvas>

	</div>
</body>

</html>
<!-- Style for main website outline -->
<style>

*{
	position: inherit;
	margin-left: 0px;
	margin-right: 0px;
	margin-top: 0px;
	margin-bottom: 0px;	
	left: 0px;
	top: 0px;
	bottom: 0px;
	right: 0px;
}

#body {
	background-color: "#FFFFDD";
	left: 0%;
	top: 0%;
	height: 100%;
	width: 100%;
}


#frame_map {
	position: inherit;
	height: 90%;
	width: 90%;
	background-color: black;
	margin-left: 2%;
	margin-right: 0px;
	margin-top: 2%;
	margin-bottom: 0px;	
	left: 0px;
	top: 0px;
	bottom: 0px;
	right: 0px;
}

#map {
	margin-left: 0px;
	margin-right: 0px;
	margin-top: 0px;
	margin-bottom: 0px;
	height: 100%;
	width: 100%;
}


</style>
<!-- Main WEBGL BOOT!! -->

<script>
//Non function script section



//Main DATA storage

//Main Loops

function mainLoop() {
	//
	renderLoop();
	//
	communicationLoop();
}

var debug = 0;

function renderLoop() {
	init_draw();
    /**
	var vertices = [
         0.0,  1.0,  0.0,
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0
    ];

    var vertices_2 = [
         0.0,  0.8,  0.0,
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0
    ];


    var vertices_3 = [
         0.0,  0.2,  0.0,
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0
    ];

    //alert("P");
    if(debug == 1) {
        addToBuffer(new Float32Array(vertices),3);
    }else if(debug == 2) {
        addToBuffer(new Float32Array(vertices_2),3);
    }else if(debug == 3) {
        addToBuffer(new Float32Array(vertices_3),3);
    }else {
        addToBuffer(new Float32Array(vertices),3);
    }
    **/
    cube = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];

    addToBufferA(cube,36);

    camRZ = toRADS(debug);
    //camRX = toRADS(debug);
    camRY = toRADS(debug);
    //vec3.add(camLoc,camLoc,vec3.fromValues(1,1,1));

	draw();
    //
    debug +=2;
    if(debug > 359) { debug = 0;}

}

function communicationLoop() {
	//
}

setInterval(mainLoop,20);//200);
//setInterval(mainLoop,100);


//Initial Loading
loadWebGL();

</script>