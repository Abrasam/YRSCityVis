<!-- Gl Matrix - matrix library-->
<script type="text/javascript" src="gl-matrix-min.js" ></script>

<!-- Util script lib by me-->
<script type="text/javascript" src="utils.js" ></script>

<script id="shader.fragment" type="x-shader/x-fragment">
    precision mediump float;


    void main(void) {
        gl_FragColor = vec4(1.0, 0.0, 1.0, 0.5);
        //gl_FragColor = vColor;
    }
</script>

<script id="shader.vertex" type="x-shader/x-vertex">
    attribute vec3 position;
    //attribute vec4 basic_color;

    uniform mat4 uFmatrix;
    uniform mat4 uMRmatrix;


    varying vec3 v;
    varying vec3 c;

    void main(void) {
    	gl_Position = uFmatrix * uMRmatrix * vec4(position,1.0);  
        //gl_Position = vec4(position,1.0) * MVmatrix * Fmatrix
        //gl_Position = vec4(position,1.0) * MVmatrix;  //MORE DEBUG
    	//gl_Position = vec4(position, 1.0);  //#DEBUG CODE - REMOVe
    }
</script>









<!-- Javascript stuff -->
<script> //UTILITY FUNCTIONALITY FOR JAVASCRIPT

//OPTIONS
var viewport_scale = 1;  //DO NOT CHANGE
var pers_scale = 2;


///////

function onResize() {
    return null; //  #NADA
    //var h = document.height;
    //var w = document.width;
    //alert(h);
    canvas = document.getElementById("map");

    var ch = canvas.height 
    var cw = canvas.width 

    //canvas.style.height = h * 0.9;
    //canvas.style.width = h * 0.9;

    gl.viewport(-cw*pers_scale,-ch*pers_scale,cw*pers_scale,ch*pers_scale);               //HACK - KINDA WORKS BUT LIMITS DISPLAY RANGE???
    //alert(gl.viewportWidth);                                                          // Could adding a scale matrix fix???
    gl.viewportHeight = ch*pers_scale;
    gl.viewportWidth = cw * pers_scale;
    alert(gl.viewportWidth);
}



function initGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width * viewport_scale;    
        gl.viewportHeight = canvas.height * viewport_scale;
        //alert("DEBUG: LOADED");
    } catch (e) {
        //DEBUG
    }
    if (!gl) {
        alert("ERROR: Failed to initialise WebGL");
    }
    /// Sneakyness

    //canvas.style.width = "100%";
   // canvas.style.height = "100%";

    var fmap = document.getElementById("frame_map");
   // fmap.style.width = "90%";
   // fmap.style.height = "90%";


    onResize();
}

//WebGL Access functionality
var gl = null;
/////
var draw_buffer = null; //Vertex Buffer to push
var draw_buffer_alt = null;
var draw_buffer_a = null;
var draw_buffer_b = null;

/////
var shaderProgram = null; //Shader
//
var Fmatrix = mat4.create();
var MRmatrix = mat4.create();
//
var camLoc = vec3.fromValues(-3, -3, -3)
//
var camRX = 5;
var camRY = 5;
var camRZ = 5;
//
var positionlocation;

function matrix_update() {
	//Camera update
	MRmatrix = mat4.create();
	//
	mat4.translate(MRmatrix,MRmatrix,camLoc);
	mat4.rotateX(MRmatrix,MRmatrix,camRX);
	mat4.rotateY(MRmatrix,MRmatrix,camRY);
	mat4.rotateZ(MRmatrix,MRmatrix,camRZ);
    //
    mat4.translate(MRmatrix,MRmatrix,camLoc);
    //
    Fmatrix = mat4.create();
    //Experimental hack location 2
    //var hack = vec3.fromValues(1/pers_scale, 1/pers_scale, 1/pers_scale);


    //mat4.scale(Fmatrix,Fmatrix,hack);  ///HACKZ PART 2

    mat4.perspective(Fmatrix,80,gl.viewportWidth / gl.viewportHeight,0.1,100);

    //Experimental added scale matrix
    //var hack = vec3.fromValues(1/pers_scale, 1/pers_scale, 1/pers_scale);

    //mat4.scale(Fmatrix,Fmatrix,hack);  ///HACKZ PART 2


	//
    //alert("DATA-MAT4: " + " mr="+mat4.str(MRmatrix)+ ", f="+mat4.str(Fmatrix));
    gl.uniformMatrix4fv(shaderProgram.fMatrixUniform, gl.FALSE, Fmatrix);
    gl.uniformMatrix4fv(shaderProgram.mrMatrixUniform, gl.FALSE, MRmatrix);
}

function addToBuffer(array,size) { //pass Float32Array
	draw_buffer_alt.numItems += size;
	gl.bufferData(gl.ARRAY_BUFFER,array, gl.STATIC_DRAW);
}

////

function switchBuffers() {
    var temp;
    temp = draw_buffer;
    draw_buffer = draw_buffer_alt;
    draw_buffer_alt = temp;
}

function bindBuffer() {
    gl.bindBuffer(gl.ARRAY_BUFFER, draw_buffer);
}


function initShaders() {
    var fragmentShader = getShader(gl, "shader.fragment");
    var vertexShader = getShader(gl, "shader.vertex");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "position");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    shaderProgram.fMatrixUniform = gl.getUniformLocation(shaderProgram, "uFmatrix");
    shaderProgram.mrMatrixUniform = gl.getUniformLocation(shaderProgram, "uMRmatrix");
}

function loadWebGL() {
    var canvas = document.getElementById("map");
    initGL(canvas);
    initShaders();
    initBuffers();
    //////
    gl.clearColor(0.0, 0.0, 0.0, 1.0);              //****** ***///   DEBUG CLEAR COLOR TESTING
    gl.enable(gl.DEPTH_TEST);

    // \/ TO TURN INTO DRAW CALLING REPEATABLE
    //////draw();

}

/////
function initBuffers() {
    draw_buffer = gl.createBuffer();
    draw_buffer_alt = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, draw_buffer);
    ////////SETUP
    draw_buffer.itemSize = 3;
    draw_buffer.numItems = 0;
    gl.bindBuffer(gl.ARRAY_BUFFER, draw_buffer);
}


function init_draw() { //RESET CURRENT BUFFER FOR REUSE
    draw_buffer.numItems = 0;
    //gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);   ///INCLUDE???
    //gl.viewport(0,0,1366,786);
    //gl.viewport(0,0,)
    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}

function addToBuffer(array,size) { //pass Float32Array
    draw_buffer.numItems += size;
    gl.bufferData(gl.ARRAY_BUFFER,array, gl.STATIC_DRAW);
}

function addToBufferA(array,size) {
    addToBuffer(new Float32Array(array),size);
}

function draw() {  //FIRST DRAW CALL PER FRAME
    //gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //TEST PROB NEEDED   DEBUG TESTING
    switchBuffers();
    bindBuffer();   
    matrix_update();
    //
    gl.vertexAttribPointer(0,3,gl.FLOAT,false,0,0);//shaderProgram.vertexPositionAttribute, draw_buffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, draw_buffer.numItems);
}


function draw_additional() {  //ADDITIONAL DRAW CALLS PER FRAME
    gl.drawArrays(gl.TRIANGLES, 0, draw_buffer.numItmes);
}





///////


</script>


<!-- Basic HTML Framework-->
<html>

<body id="body">

	<div id="frame_map" >

		<canvas id="map" onResize="onResize();">


		</canvas>

	</div>
</body>

</html>
<!-- Style for main website outline -->
<style>

*{
	position: inherit;
	margin-left: 0px;
	margin-right: 0px;
	margin-top: 0px;
	margin-bottom: 0px;	
	left: 0px;
	top: 0px;
	bottom: 0px;
	right: 0px;
}

#body {
	background-color: "#FFFFDD";
	left: 0%;
	top: 0%;
	height: 100%;
	width: 100%;
}


#frame_map {
	position: inherit;
	height: 90%;
	width: 90%;
    /**
    height: 786px;
    width: 1366px;
    **/

    /***/
	background-color: black;
	margin-left: 2%;
	margin-right: 0px;
    /**
    margin-left: 10px;
    margin-top: 10px;**/
	margin-top: 2%;
	margin-bottom: 0px;	
	left: 0px;
	top: 0px;
	bottom: 0px;
	right: 0px;
}

#map {
	margin-left: 0px;
	margin-right: 0px;
	margin-top: 0px;
	margin-bottom: 0px;
    
	height: 100%;
	width: 100%;
    /**
    height: 786px;
    width: 1366px; **/
}

canvas {  /** CSS GRAPHICS NINJANESS  --- ALTHOUGH I AM NOT SURE IT WORKS**/

  width: 200%;
  height: 200%;

/**
    width: 1920px;
    height: 1080px;
**/
}

</style>
<!-- Main WEBGL BOOT!! -->

<script>
//Non function script section



//Main DATA storage

//Main Loops

function mainLoop() {
	//
	renderLoop();
    //
    inputLoop();
	//
	communicationLoop();
}

var debug = 0;

function renderLoop() {
	init_draw();
    /**
	var vertices = [
         0.0,  1.0,  0.0,
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0
    ];

    var vertices_2 = [
         0.0,  0.8,  0.0,
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0
    ];


    var vertices_3 = [
         0.0,  0.2,  0.0,
        -1.0, -1.0,  0.0,
         1.0, -1.0,  0.0
    ];

    //alert("P");
    if(debug == 1) {
        addToBuffer(new Float32Array(vertices),3);
    }else if(debug == 2) {
        addToBuffer(new Float32Array(vertices_2),3);
    }else if(debug == 3) {
        addToBuffer(new Float32Array(vertices_3),3);
    }else {
        addToBuffer(new Float32Array(vertices),3);
    }
    **/
    cube = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
        ];

    addToBufferA(cube,36);

    //camRZ = toRADS(debug);
    camRX = toRADS(debug);
    camRY = toRADS(debug);
    //vec3.add(camLoc,camLoc,vec3.fromValues(1,1,1));

	draw();
    //
    debug +=2;
    if(debug > 359) { debug = 0;}

}

function communicationLoop() {
	//
}

function inputLoop() {

    if(keys[87]) { //W

    }
    //
    if(keys[65]) { //A

    }
    //
    if(keys[83]) { //S

    }
    //
    if(keys[68]) { //D

    }

    //


    if(keys[27]) { //Esc

    }


}

//Handlers

//var w_k = false;
//var a_k = false;
//var d_k = false;
//var s_k = false;
//var esc = false;
var keys = [];


window.addEventListener("keydown", key_down, false);
window.addEventListener("keypress", key_press, false);
window.addEventListener("keyup", key_up, false);
 
function key_down(e) {
    keys[e.keyCode] = true;
}

function key_press(e) {
    keys[e.keyCode] = true;
}

function key_up(e) {
    keys[e.keyCode] = false;
}



/////////

setInterval(mainLoop,20);//200);
//setInterval(mainLoop,100);


//Initial Loading
loadWebGL();

</script>